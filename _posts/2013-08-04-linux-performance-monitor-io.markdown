---
author: pandao
comments: false
date: 2013-08-04 23:22:32+00:00
layout: post
slug: linux-performance-monitor-io
title: Linux性能监测IO
thread: 232
categories:
- linux
---







磁盘通常是计算机最慢的子系统，也是最容易出现性能瓶颈的地方，因为磁盘离 CPU 距离最远而且 CPU 访问磁盘要涉及到机械操作，比如转轴、寻轨等。访问硬盘和访问内存之间的速度差别是以数量级来计算的，就像1天和1分钟的差别一样。要监测 IO 性能，有必要了解一下基本原理和 Linux 是如何处理硬盘和内存之间的 IO 的。


## 内存页


上一篇 [Linux 性能监测：Memory](http://linux.cn/article-1771-1.html) 提到了内存和硬盘之间的 IO 是以页为单位来进行的，在 Linux 系统上1页的大小为 4K。可以用以下命令查看系统默认的页面大小：





·········10········20········30········40········50········60········







`1.``$ /usr/bin/``time` `-``v` `date`




`2.``...`




`3.``Page size (bytes): 4096`




`4.``...`










## 缺页中断


Linux 利用虚拟内存极大的扩展了程序地址空间，使得原来物理内存不能容下的程序也可以通过内存和硬盘之间的不断交换（把暂时不用的内存页交换到硬盘，把需要的内 存页从硬盘读到内存）来赢得更多的内存，看起来就像物理内存被扩大了一样。事实上这个过程对程序是完全透明的，程序完全不用理会自己哪一部分、什么时候被 交换进内存，一切都有内核的虚拟内存管理来完成。当程序启动的时候，Linux 内核首先检查 CPU 的缓存和物理内存，如果数据已经在内存里就忽略，如果数据不在内存里就引起一个缺页中断（Page Fault），然后从硬盘读取缺页，并把缺页缓存到物理内存里。缺页中断可分为主缺页中断（Major Page Fault）和次缺页中断（Minor Page Fault），要从磁盘读取数据而产生的中断是主缺页中断；数据已经被读入内存并被缓存起来，从内存缓存区中而不是直接从硬盘中读取数据而产生的中断是次 缺页中断。

上面的内存缓存区起到了预读硬盘的作用，内核先在物理内存里寻找缺页，没有的话产生次缺页中断从内存缓存里找，如果还没有发现的话就从硬盘读取。很 显然，把多余的内存拿出来做成内存缓存区提高了访问速度，这里还有一个命中率的问题，运气好的话如果每次缺页都能从内存缓存区读取的话将会极大提高性能。 要提高命中率的一个简单方法就是增大内存缓存区面积，缓存区越大预存的页面就越多，命中率也会越高。下面的 time 命令可以用来查看某程序第一次启动的时候产生了多少主缺页中断和次缺页中断：





·········10········20········30········40········50········60········







`1.``$ /usr/bin/``time` `-``v` `date`




`2.``...`




`3.``Major (requiring I/O) page faults: 1`




`4.``Minor (reclaiming a frame) page faults: 260`




`5.``...`










## File Buffer Cache


从上面的内存缓存区（也叫文件缓存区 File Buffer Cache）读取页比从硬盘读取页要快得多，所以 Linux 内核希望能尽可能产生次缺页中断（从文件缓存区读），并且能尽可能避免主缺页中断（从硬盘读），这样随着次缺页中断的增多，文件缓存区也逐步增大，直到系 统只有少量可用物理内存的时候 Linux 才开始释放一些不用的页。我们运行 Linux 一段时间后会发现虽然系统上运行的程序不多，但是可用内存总是很少，这样给大家造成了 Linux 对内存管理很低效的假象，事实上 Linux 把那些暂时不用的物理内存高效的利用起来做预存（内存缓存区）呢。下面打印的是 VPSee 的一台 Sun 服务器上的物理内存和文件缓存区的情况：





·········10········20········30········40········50········60········







`1.``$ ``cat` `/proc/meminfo`




`2.``MemTotal:      8182776 kB`




`3.``MemFree:       3053808 kB`




`4.``Buffers:        342704 kB`




`5.``Cached:        3972748 kB`








这台服务器总共有 8GB 物理内存（MemTotal），3GB 左右可用内存（MemFree），343MB 左右用来做磁盘缓存（Buffers），4GB 左右用来做文件缓存区（Cached），可见 Linux 真的用了很多物理内存做 Cache，而且这个缓存区还可以不断增长。


## 页面类型


Linux 中内存页面有三种类型：



	
  * Read pages，只读页（或代码页），那些通过主缺页中断从硬盘读取的页面，包括不能修改的静态文件、可执行文件、库文件等。当内核需要它们的时候把它们读到 内存中，当内存不足的时候，内核就释放它们到空闲列表，当程序再次需要它们的时候需要通过缺页中断再次读到内存。

	
  * Dirty pages，脏页，指那些在内存中被修改过的数据页，比如文本文件等。这些文件由 pdflush 负责同步到硬盘，内存不足的时候由 kswapd 和 pdflush 把数据写回硬盘并释放内存。

	
  * Anonymous pages，匿名页，那些属于某个进程但是又和任何文件无关联，不能被同步到硬盘上，内存不足的时候由 kswapd 负责将它们写到交换分区并释放内存。




## IO’s Per Second（IOPS）


每次磁盘 IO 请求都需要一定的时间，和访问内存比起来这个等待时间简直难以忍受。在一台 2001 年的典型 1GHz PC 上，磁盘随机访问一个 word 需要 8,000,000 nanosec = 8 millisec，顺序访问一个 word 需要 200 nanosec；而从内存访问一个 word 只需要 10 nanosec.（数据来自：[Teach Yourself Programming in Ten Years](http://norvig.com/21-days.html)）这个硬盘可以提供 125 次 IOPS（1000 ms / 8 ms）。


## 顺序 IO 和 随机 IO


IO 可分为顺序 IO 和 随机 IO 两种，性能监测前需要弄清楚系统偏向顺序 IO 的应用还是随机 IO 应用。顺序 IO 是指同时顺序请求大量数据，比如数据库执行大量的查询、流媒体服务等，顺序 IO 可以同时很快的移动大量数据。可以这样来评估 IOPS 的性能，用每秒读写 IO 字节数除以每秒读写 IOPS 数，rkB/s 除以 r/s，wkB/s 除以 w/s. 下面显示的是连续2秒的 IO 情况，可见每次 IO 写的数据是增加的（45060.00 / 99.00 = 455.15 KB per IO，54272.00 / 112.00 = 484.57 KB per IO）。相对随机 IO 而言，顺序 IO 更应该重视每次 IO 的吞吐能力（KB per IO）：





·········10········20········30········40········50········60········







`01.``$ iostat -kx 1`




`02.``avg-cpu:  %user   %``nice` `%system %iowait  %steal   %idle`




`03.``0.00    0.00    2.50   25.25    0.00   72.25`




`04.`




`05.``Device:  rrqm/s   wrqm/s   r/s   w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await  svctm  %util`




`06.``sdb       24.00 19995.00 29.00 99.00  4228.00 45060.00   770.12    45.01  539.65   7.80  99.80`




`07.`




`08.``avg-cpu:  %user   %``nice` `%system %iowait  %steal   %idle`




`09.``0.00    0.00    1.00   30.67    0.00   68.33`




`10.`




`11.``Device:  rrqm/s   wrqm/s   r/s   w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await  svctm  %util`




`12.``sdb        3.00 12235.00  3.00 112.00   768.00 54272.00   957.22   144.85  576.44   8.70 100.10`








随机 IO 是指随机请求数据，其 IO 速度不依赖于数据的大小和排列，依赖于磁盘的每秒能 IO 的次数，比如 Web 服务、Mail 服务等每次请求的数据都很小，随机 IO 每秒同时会有更多的请求数产生，所以磁盘的每秒能 IO 多少次是关键。





·········10········20········30········40········50········60········







`01.``$ iostat -kx 1`




`02.``avg-cpu:  %user   %``nice` `%system %iowait  %steal   %idle`




`03.``1.75    0.00    0.75    0.25    0.00   97.26`




`04.`




`05.``Device:  rrqm/s   wrqm/s   r/s   w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await  svctm  %util`




`06.``sdb        0.00    52.00  0.00 57.00     0.00   436.00    15.30     0.03    0.54   0.23   1.30`




`07.`




`08.``avg-cpu:  %user   %``nice` `%system %iowait  %steal   %idle`




`09.``1.75    0.00    0.75    0.25    0.00   97.24`




`10.`




`11.``Device:  rrqm/s   wrqm/s   r/s   w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await  svctm  %util`




`12.``sdb        0.00    56.44  0.00 66.34     0.00   491.09    14.81     0.04    0.54   0.19   1.29`








按照上面的公式得出：436.00 / 57.00 = 7.65 KB per IO，491.09 / 66.34 = 7.40 KB per IO. 与顺序 IO 比较发现，随机 IO 的 KB per IO 小到可以忽略不计，可见对于随机 IO 而言重要的是每秒能 IOPS 的次数，而不是每次 IO 的吞吐能力（KB per IO）。


## SWAP


当系统没有足够物理内存来应付所有请求的时候就会用到 swap 设备，swap 设备可以是一个文件，也可以是一个磁盘分区。不过要小心的是，使用 swap 的代价非常大。如果系统没有物理内存可用，就会频繁 swapping，如果 swap 设备和程序正要访问的数据在同一个文件系统上，那会碰到严重的 IO 问题，最终导致整个系统迟缓，甚至崩溃。swap 设备和内存之间的 swapping 状况是判断 Linux 系统性能的重要参考，我们已经有很多工具可以用来监测 swap 和 swapping 情况，比如：top、cat /proc/meminfo、vmstat 等：





·········10········20········30········40········50········60········







`01.``$ ``cat` `/proc/meminfo`




`02.``MemTotal:      8182776 kB`




`03.``MemFree:       2125476 kB`




`04.``Buffers:        347952 kB`




`05.``Cached:        4892024 kB`




`06.``SwapCached:        112 kB`




`07.``...`




`08.``SwapTotal:     4096564 kB`




`09.``SwapFree:      4096424 kB`




`10.``...`




`11.`




`12.``$ vmstat 1`




`13.``procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu------`




`14.``r  b   swpd   ``free`   `buff  cache   si   so    bi    bo   ``in`   `cs us sy ``id` `wa st`




`15.``1  2 260008   2188    144   6824 11824 2584 12664  2584 1347 1174 14  0  0 86  0`




`16.``2  1 262140   2964    128   5852 24912 17304 24952 17304 4737 2341 86 10  0  0  4`











